/*
 * Copyright Â© 2016 Cask Data, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package co.cask.tracker.entity;

import co.cask.cdap.api.common.Bytes;
import co.cask.cdap.api.dataset.DatasetSpecification;
import co.cask.cdap.api.dataset.lib.AbstractDataset;
import co.cask.cdap.api.dataset.module.EmbeddedDataset;
import co.cask.cdap.api.dataset.table.Put;
import co.cask.cdap.api.dataset.table.Row;
import co.cask.cdap.api.dataset.table.Table;
import co.cask.cdap.proto.audit.AuditMessage;
import co.cask.cdap.proto.audit.AuditType;
import co.cask.cdap.proto.audit.payload.access.AccessPayload;
import co.cask.cdap.proto.id.EntityId;
import co.cask.cdap.proto.id.NamespacedEntityId;
import co.cask.tracker.utils.ParameterCheck;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Stores timestamp of audit messages with AuditType access (read or write), truncate, update, and metadata_change
 * Rows hold data for individual entities. Timestamp of received message type are stored in each column.
 * Row key generated by getKey(). Column key is AuditType (lower case).
 */
public final class LatestEntityTable extends AbstractDataset {

  private final Table timeSinceTable;

  public LatestEntityTable(DatasetSpecification spec,
                           @EmbeddedDataset("timeSinceTable") Table timeSinceTable) {
    super(spec.getName(), timeSinceTable);
    this.timeSinceTable = timeSinceTable;
  }

  public void write(AuditMessage auditMessage) throws IOException {
    if (auditMessage.getType() == AuditType.CREATE || auditMessage.getType() == AuditType.DELETE) {
      return;
    }
    EntityId entityId = auditMessage.getEntityId();
    if (!(entityId instanceof NamespacedEntityId)) {
      throw
        new IllegalStateException(String.format("Entity '%s' does not have a namespace " +
                                                  "and was not written to LatestEntityTable",
                                                entityId));
    }
    if (ParameterCheck.isTrackerDataset(entityId)) {
      return;
    }
    String namespace = ((NamespacedEntityId) entityId).getNamespace();
    String entityName = entityId.getEntityName();
    String entityType = entityId.getEntity().name();
    String key = getKey(namespace, entityType, entityName);
    String timeSinceType = auditMessage.getType().name().toLowerCase();
    if (auditMessage.getType() == AuditType.ACCESS) {
      timeSinceType = ((AccessPayload) auditMessage.getPayload()).getAccessType().name().toLowerCase();
    }
    timeSinceTable.put(new Put(key).add(timeSinceType, auditMessage.getTime() / 1000));
  }

  public TimeSinceResult read(String namespace, String entityType, String entityName) {
    String key = getKey(namespace, entityType, entityName);
    Row row = timeSinceTable.get(key.getBytes());
    TimeSinceResult timeSinceResult = new TimeSinceResult(namespace, entityType, entityName);
    Map<byte[], byte[]> columnValues = row.getColumns();
    for (byte[] column : columnValues.keySet()) {
      timeSinceResult.addEventTime(Bytes.toString(column), row.getLong(column));
    }
    return timeSinceResult;
  }

  public Map<Entity, Long> getReadTimestamps(String namespace, List<Entity> entityList) {
    Map<Entity, Long> resultMap = new HashMap<>();
    for (Entity  uniqueEntity: entityList) {
      Map<String, Long> timeMap
        = read(namespace, uniqueEntity.getEntityType(), uniqueEntity.getEntityName()).getTimeSinceEvents();
      if (timeMap.containsKey("read")) {
        resultMap.put(uniqueEntity, timeMap.get("read"));
      }
    }
    return resultMap;
  }

  private String getKey(String namespace, String entityType, String entityName) {
    return String.format("%s%s%s%s%s%s",
                         Integer.toString(namespace.length()), namespace.toLowerCase(),
                         Integer.toString(entityType.length()), entityType.toLowerCase(),
                         Integer.toString(entityName.length()), entityName.toLowerCase());
  }
}
